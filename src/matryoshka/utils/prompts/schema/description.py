import json

CONSTANTS = ["SYNTAX", "KEY"]

instructions = """# Description Writing Instructions

## Core Principles
1. **Scope**: Write descriptions that characterize the role of tokens in log events, not their values.
2. **Independence**: Descriptions must remain valid regardless of the specific values observed in any instance.

## Quality Requirements

### Completeness
- Include all information necessary to understand the variable's role
- Cover the full scope of the variable's function in the context
- Explain any relevant relationships with other fields

### Precision
- Use accurate technical terminology
- Avoid ambiguous or vague language
- Be explicit about the variable's purpose
- Maintain consistent technical depth

### Soundness
- Ensure descriptions align with the technical reality of the variable's role
- Avoid misleading or incorrect characterizations
- Stay within the bounds of what is definitively known about the variable

### Describing Constants
- Constants that contain information that might be relevant to an analyst should be described.
- Constants that are purely syntax and contain no semantic meaning should be assigned description "SYNTAX".
- Constants that do not contain information should be described as "SYNTAX".
- Constants whose meaning is not obvious or do not represent a queryable field should be described as "SYNTAX".
- Key in key-value pairs should be described as "KEY".

## Guidelines for Consistency

### Cross-Reference Requirements
- When describing a token similar to one previously described:
  - Review the earlier description
  - Maintain consistent terminology
  - Use parallel structure
  - Preserve the same level of detail

### Language Standards
- Use clear, professional technical writing
- Write in complete sentences
- Maintain consistent verb tense
- Use active voice

## What to Avoid
- Specific values or examples
- Assumptions about typical or possible values
- Instance-specific observations
- References to implementation details that may change
- Speculative functionality"""

system = """You are an expert log parser. You are given a few log lines that have been generated by the same program. These lines have been separated into tokens. Some of these tokens are variables. Others are constants. Your task is to provide a field description for each token.

{instructions}

*** Context-Aware Information ***
All tokens you are annotating are part of log templates for a specific log file. This log file is described as:
```
{log_desc}
```

*** Format ***
The output format must be a JSON object with the following structure:
```
{{
    <token_id>: <description>,
    ...
}}
``` 
"""


user_input = """The following lines have been generated by the same program:
```
{lines}
```

We have determined they can be parsed using the following template:
```
{template}
```"""


def gen_fewshot():
    fewshot_prompts = []
    for fs_lines, fs_template, fs_output in fixed_few_shot_examples:
        lines = "\n".join(fs_lines)
        if isinstance(fs_template, str):
            template = fs_template
        else:
            template = fs_template.format_as_example(
                force_match_with_entry=True,
                entry=fs_lines[0],
                types=True,
                ids=True,
            )
        if isinstance(fs_output, str):
            response = fs_output
        else:
            response = json.dumps(fs_output, indent=2)

        prompt = user_input.format(lines=lines, template=template)
        fewshot_prompts.append({"role": "user", "content": prompt})
        fewshot_prompts.append({"role": "assistant", "content": response})

    return fewshot_prompts


def gen_system(log_desc):
    return system.format(instructions=instructions, log_desc=log_desc)


def gen_prompt(elt, log_desc):
    lines, template = elt
    if not lines:
        breakpoint()
    if not isinstance(template, str):
        template = template.format_as_example(
            force_match_with_entry=True,
            entry=lines[0],
            regex=True,
            types=True,
            ids=True,
        )
    lines = "\n".join(lines)

    fewshot = gen_fewshot()

    prompt = (
        user_input.format(
            lines=lines,
            template=template,
        )
        + "\n"
        + instructions
    )

    return prompt, fewshot, gen_system(log_desc)


def gen_fixed_fewshot():
    few_shot_examples = []
    example_lines = [
        'Sep 12 10:17:03 tohuvabohu.balabit audispd[1026]: node=server1.company.com type=ANOM_ABEND msg=audit(1410509823.256:24937): auid=1000 uid=1000 gid=1000 ses=13 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=3759 comm="gmain" exe="/usr/bin/caja" sig=11',
        'Oct 17 22:12:33 tohuvabohu.balabit audispd[1030]: node=server1.company.com type=ANOM_ABEND msg=audit(1413576753.722:253): auid=1000 uid=1000 gid=1000 ses=2 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=2755 comm="cinnamon" exe="/usr/bin/cinnamon" sig=11',
        'Sep 15 14:23:45 server1.company.com audispd[2047]: node=db2.company.com type=ANOM_ABEND msg=audit(1410678925.123:35891): auid=2000 uid=2000 gid=2000 ses=24 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=4891 comm="apache2" exe="/usr/sbin/apache2" sig=6',
        'Sep 18 03:15:22 db2.company.com audispd[3098]: node=tohuvabohu.balabit type=ANOM_ABEND msg=audit(1410891322.445:47129): auid=3000 uid=3000 gid=3000 ses=31 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=5922 comm="mysqld" exe="/usr/sbin/mysqld" sig=11',
        'Sep 21 19:45:11 cache3.company.com audispd[4156]: node=tohuvabohu.balabit type=ANOM_ABEND msg=audit(1411321511.789:58234): auid=4000 uid=4000 gid=4000 ses=42 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=7845 comm="redis-server" exe="/usr/bin/redis-server" sig=9',
    ]

    example_template = """[
{
"is_variable": true,
"value": "Sep 12 10:17:03",
"id": 1
},
{
"is_variable": true,
"value": "tohuvabohu.balabit", 
"id": 2
},
{
"is_variable": false,
"value": "audispd",
"id": 3
},
{
"is_variable": false,
"value": "[",
"id": 4
},
{
"is_variable": true,
"value": "1026",
"id": 5
},
{
"is_variable": false,
"value": "]",
"id": 6
},
{
"is_variable": false,
"value": "node=",
"id": 7
},
{
"is_variable": true,
"value": "tohuvabohu.balabit",
"id": 8
},
{
"is_variable": false,
"value": "type=",
"id": 9
},
{
"is_variable": true,
"value": "ANOM_ABEND",
"id": 10
},
{
"is_variable": false,
"value": "msg=audit(",
"id": 11
},
{
"is_variable": true,
"value": "1410509823.256",
"id": 12
},
{
"is_variable": false,
"value": ":",
"id": 13
},
{
"is_variable": true,
"value": "24937",
"id": 14
},
{
"is_variable": false,
"value": "): auid=",
"id": 15
},
{
"is_variable": true,
"value": "1000",
"id": 16
},
{
"is_variable": false,
"value": "uid=",
"id": 17
},
{
"is_variable": true,
"value": "1000",
"id": 18
},
{
"is_variable": false,
"value": "gid=",
"id": 19
},
{
"is_variable": true,
"value": "1000",
"id": 20
},
{
"is_variable": false,
"value": "ses=",
"id": 21
},
{
"is_variable": true,
"value": "13",
"id": 22
},
{
"is_variable": false,
"value": "subj=",
"id": 23
},
{
"is_variable": true,
"value": "unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023",
"id": 24
},
{
"is_variable": false,
"value": "pid=",
"id": 25
},
{
"is_variable": true,
"value": "3759",
"id": 26
},
{
"is_variable": false,
"value": "comm=\"",
"id": 27
},
{
"is_variable": true,
"value": "gmain",
"id": 28
},
{
"is_variable": false,
"value": "\" exe=\"",
"id": 29
},
{
"is_variable": true,
"value": "/usr/bin/caja",
"id": 30
},
{
"is_variable": false,
"value": "\" sig=",
"id": 31
},
{
"is_variable": true,
"value": "11",
"id": 32
}
]"""

    example_output = {
        1: "The exact date and time when the audit event was recorded by the system, in local timezone format.",
        2: "The hostname of the system where the audit event was logged. This is different from the hostname of the system where the reported event occurred.",
        3: "The name of the process that generated the event.",
        4: "SYNTAX",
        5: "The process identifier (pid) of the audit dispatcher daemon that forwarded this audit event to the logging system",
        6: "SYNTAX",
        7: "KEY",
        8: "The hostname of the system where the reported event occurred. This is different from the hostname of the system where the audit event was logged.",
        9: "KEY",
        10: "The classification type of the audit event.",
        11: "KEY",
        12: "The Unix timestamp when the event occurred, with millisecond precision.",
        13: "SYNTAX",
        14: "The unique serial number assigned to this audit event, which helps maintain sequence and identify specific events in audit logs",
        15: "KEY",
        16: "The audit user ID (audit user ID) of the user that ran the program or application that triggered this event. This ID is assigned to a user upon login and is inherited by every process even when the user's identity changes (for example, by switching user accounts with su - john).",
        17: "KEY",
        18: "The user ID (uid) of the user that ran the program or application that triggered this event.",
        19: "KEY",
        20: "The primary group ID (gid) of the user that ran the program or application that triggered this event.",
        21: "KEY",
        22: "The unique session identifier assigned when the user logged in, used to group all audit events from the same login session",
        23: "KEY",
        24: "The full SELinux security context of the process at the time of the event, including user, role, type, and sensitivity level information used for mandatory access control",
        25: "KEY",
        26: "The process ID (pid) of the specific program or application that generated the audit event, used to track the exact process instance involved",
        27: "KEY",
        28: "The command name or process name of the program that generated the audit event, typically derived from the executable name or how the process was invoked",
        29: "KEY",
        30: "The full path to the executable file that was running when the audit event occurred, helping identify the exact program involved in the event",
        31: "KEY",
        32: "The signal number that caused the process to terminate abnormally.",
    }

    few_shot_examples.append((example_lines, example_template, example_output))

    example_lines = [
        "update-alternatives 2022-10-04 22:32:23: run with --install /usr/bin/groovysh groovysh /usr/share/groovy/bin/groovysh 20 --slave /usr/bin/groovy groovy /usr/share/groovy/bin/groovy --slave /usr/share/man/man1/groovysh.1.gz groovysh.1.gz /usr/share/groovy/man/man1/groovysh.1.gz",
        "update-alternatives 2022-10-04 22:35:45: run with --install /usr/bin/java java /usr/lib/jvm/java-11/bin/java 100 --slave /usr/bin/javac javac /usr/lib/jvm/java-11/bin/javac --slave /usr/share/man/man1/java.1.gz java.1.gz /usr/lib/jvm/java-11/man/man1/java.1.gz",
        "update-alternatives 2022-10-04 22:37:12: run with --install /usr/bin/python python /usr/bin/python3.8 30 --slave /usr/bin/python-config python-config /usr/bin/python3.8-config --slave /usr/share/man/man1/python.1.gz python.1.gz /usr/share/man/man1/python3.8.1.gz",
        "update-alternatives 2022-10-04 22:38:01: run with --install /usr/bin/gcc gcc /usr/bin/gcc-9 50 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/share/man/man1/gcc.1.gz gcc.1.gz /usr/share/man/man1/gcc-9.1.gz",
        "update-alternatives 2022-10-04 22:39:15: run with --install /usr/bin/node node /usr/local/node-v14/bin/node 40 --slave /usr/bin/npm npm /usr/local/node-v14/bin/npm --slave /usr/share/man/man1/node.1.gz node.1.gz /usr/local/node-v14/share/man/man1/node.1.gz",
    ]

    example_template = """[
{
"is_variable": false,
"value": "update-alternatives",
"id": 1
},
{
"is_variable": true,
"value": "2022-10-04 22:32:23",
"id": 2
},
{
"is_variable": false,
"value": ": run with --install",
"id": 3
},
{
"is_variable": true,
"value": "/usr/bin/groovysh",
"id": 4
},
{
"is_variable": true,
"value": "groovysh",
"id": 5
},
{
"is_variable": true,
"value": "/usr/share/groovy/bin/groovysh",
"id": 6
},
{
"is_variable": true,
"value": "20",
"id": 7
},
{
"is_variable": false,
"value": "--slave",
"id": 8
},
{
"is_variable": true,
"value": "/usr/bin/groovy",
"id": 9
},
{
"is_variable": true,
"value": "groovy",
"id": 10
},
{
"is_variable": true,
"value": "/usr/share/groovy/bin/groovy",
"id": 11
},
{
"is_variable": false,
"value": "--slave",
"id": 12
},
{
"is_variable": true,
"value": "/usr/share/man/man1/groovysh.1.gz",
"id": 13
},
{
"is_variable": true,
"value": "groovysh.1.gz",
"id": 14
},
{
"is_variable": true,
"value": "/usr/share/groovy/man/man1/groovysh.1.gz",
"id": 15
}
]"""

    example_output = {
        1: "The name of the process that generated the event.",
        2: "The date and time when the log event was recorded in the alternatives system. This timestamp helps track when changes were made to the system's alternative configurations.",
        3: "KEY",
        4: "The destination path where an alternative link will be created in the filesystem. This symbolic link will point to one of several possible implementations of the command.",
        5: "The name of the link group for this alternative in the system. This identifier is used to group related alternatives together and manage them as a set.",
        6: "The path to the actual executable being installed as an alternative. This is the real file that will be executed when the alternative link is used.",
        7: "The priority of this alternative in the system's selection process. Higher numbers indicate higher priority, which determines which alternative becomes the default when automatic mode is enabled.",
        8: "KEY",
        9: "The destination path for a slave link that is associated with the main alternative. Slave links are secondary symlinks that are updated along with the master alternative.",
        10: "The name of a slave link in the alternatives system. This identifier helps manage secondary components that should be switched together with the main alternative.",
        11: "The path to the actual file for a slave alternative. This is the real file that the slave symlink will point to when this alternative is selected.",
        12: "KEY",
        13: "The destination path for a slave link that is associated with the main alternative. Slave links are secondary symlinks that are updated along with the master alternative.",
        14: "The name of a slave link in the alternatives system. This identifier helps manage secondary components that should be switched together with the main alternative.",
        15: "The path to the actual file for a slave alternative. This is the real file that the slave symlink will point to when this alternative is selected.",
    }

    few_shot_examples.append((example_lines, example_template, example_output))

    return few_shot_examples


fixed_few_shot_examples = gen_fixed_fewshot()
