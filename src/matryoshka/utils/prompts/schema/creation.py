system = """You are an expert log parser. You are given a few log lines that have been generated by the same program. These lines have been separated into constant tokens and entities, and each entity has been given a description. Your task is to provide a schema for these log lines that assigns each entity a field name and description.

# Field Naming Instructions

## Core Principles
1. **Abstract Role**: Names must represent the fundamental semantic role of the field in the event structure, independent of:
   - Any specific values it might contain
   - The specific system generating the log
   - The specific type of event being logged
   
2. **Structural Context**: Names should reflect the field's position and purpose in the event's logical structure:
   - What information does this field provide about the event?
   - How does this field relate to other fields?
   - What aspect of the event does this field describe?

3. **Universal Applicability**: Names must be valid across:
   - All possible values the field could contain
   - All types of events where this field appears
   - All systems that might generate similar events

## Implementation Rules

1. **Format**:
   - Use snake_case
   - Use singular nouns
   - Avoid vendor names, product names, or technology-specific terms
   - Maximum 3 words joined by underscores

2. **Field Grouping**:
   - Fields serving the same semantic role MUST use identical names
   - When grouping fields, list all matching IDs in the schema
   - Cross-reference previous schemas to maintain consistency

3. **Naming Structure**:
   - If the original element included a field_name, please reuse it
   - Start with the most general category (e.g., 'time', 'sequence', 'host')
   - Add specificity only when needed to disambiguate
   - Maintain parallel structure across related fields

## Validation Checklist

Before finalizing field names, verify:
1. Would the name still make sense if the field contained different values?
2. Does the name depend on any specific technology or system?
3. Is this name identical to names used for similar fields in other schemas?
4. Could this field appear in other types of events with the same meaning?

## What to Avoid

1. **Technology-Specific Terms**:
   - No implementation-specific terminology

2. **Value-Based Names**:
   - No names that describe specific values
   - No names that assume specific formats or types
   - No names that limit the field's interpretation

3. **Overly Specific Names**:
   - No names that incorporate current use cases
   - No names that assume specific contexts
   - No names that limit future applications
   
4. **Overly Generic Names**:
   - No names that are too broad or vague
   - No names that could apply to multiple unrelated fields
"""


user_input = """The following lines have been generated by the same program:
```
{lines}
```

We have determined they can be parsed using the following template:
```
{template}
```

Please provide a schema for these log lines. Follow the intrustions provided above.
"""

consistency_addon = """ Most importantly, make sure to be consistent with previous schemas: any field that has the same purpose or role as in a prior schema should use the same field name. Use previous schemas as a reference to ensure consistency across different log lines and templates. Make sure fields representing the same attribute or concept have the same name."""


def gen_fewshot(examples, field_mapping=None, descriptions=None):
    if not examples:
        examples = []

    fewshot_prompts = []
    for fs_lines, fs_template, fs_output in fixed_few_shot_examples + examples:
        lines = "\n".join(fs_lines)
        if isinstance(fs_template, str):
            template = fs_template
        else:
            template = fs_template.format_as_example(
                force_match_with_entry=True,
                entry=fs_lines[0],
                regex=True,
                ids=True,
                descriptions=descriptions,
                field_names=field_mapping,
            )
        if isinstance(fs_output, str):
            response = fs_output
        else:
            response = fs_output.to_json()

        prompt = user_input.format(lines=lines, template=template)
        fewshot_prompts.append({"role": "user", "content": prompt})
        fewshot_prompts.append({"role": "assistant", "content": response})

    return fewshot_prompts


def gen_system():
    return system


def gen_prompt(elt, few_shot_examples, field_mapping=None, descriptions=None):
    lines, template = elt
    if not isinstance(template, str):
        template = template.format_as_example(
            force_match_with_entry=True,
            entry=lines[0],
            regex=True,
            ids=True,
            descriptions=descriptions,
            field_names=field_mapping,
        )
    lines = "\n".join(lines)

    fewshot = gen_fewshot(few_shot_examples, field_mapping, descriptions)

    prompt = (
        user_input.format(
            lines=lines,
            template=template,
        )
        + consistency_addon
    )

    return prompt, fewshot, gen_system()


def gen_fixed_fewshot():
    few_shot_examples = []
    example_lines = [
        'Sep 12 10:17:03 tohuvabohu.balabit audispd[1026]: node=tohuvabohu.balabit type=ANOM_ABEND msg=audit(1410509823.256:24937): auid=1000 uid=1000 gid=1000 ses=13 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=3759 comm="gmain" exe="/usr/bin/caja" sig=11',
        'Oct 17 22:12:33 tohuvabohu.balabit audispd[1030]: node=tohuvabohu.balabit type=ANOM_ABEND msg=audit(1413576753.722:253): auid=1000 uid=1000 gid=1000 ses=2 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=2755 comm="cinnamon" exe="/usr/bin/cinnamon" sig=11',
        'Sep 15 14:23:45 server1.company.com audispd[2047]: node=server1.company.com type=ANOM_ABEND msg=audit(1410678925.123:35891): auid=2000 uid=2000 gid=2000 ses=24 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=4891 comm="apache2" exe="/usr/sbin/apache2" sig=6',
        'Sep 18 03:15:22 db2.company.com audispd[3098]: node=db2.company.com type=ANOM_ABEND msg=audit(1410891322.445:47129): auid=3000 uid=3000 gid=3000 ses=31 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=5922 comm="mysqld" exe="/usr/sbin/mysqld" sig=11',
        'Sep 21 19:45:11 cache3.company.com audispd[4156]: node=cache3.company.com type=ANOM_ABEND msg=audit(1411321511.789:58234): auid=4000 uid=4000 gid=4000 ses=42 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=7845 comm="redis-server" exe="/usr/bin/redis-server" sig=9',
    ]
    example_template = """[
    {
        "is_variable": true,
        "value": "Sep 12 10:17:03",
        "regex": "[A-Za-z]+\\s+\\d+\\s+\\d+:\\d+:\\d+",
        "id": 1,
        "description": "The exact date and time when the audit event was recorded by the system, in local timezone format.",
        "field_name": "log_timestamp"
    },
    {
        "is_variable": true,
        "value": "tohuvabohu.balabit", 
        "regex": "[\\w.-]+",
        "id": 2,
        "description": "The hostname of the system where the audit event was logged. This is different from the hostname of the system where the reported event occurred.",
        "field_name": "log_host"
    },
    {
        "is_variable": false,
        "value": "audispd",
        "id": 3
    },
    {
        "is_variable": false,
        "value": "[",
        "id": 4
    },
    {
        "is_variable": true,
        "value": "1026",
        "regex": "\\d+", 
        "id": 5,
        "description": "The process identifier (pid) of the audit dispatcher daemon that forwarded this audit event to the logging system",
        "field_name": "dispatcher_pid"
    },
    {
        "is_variable": false,
        "value": "]",
        "id": 6
    },
    {
        "is_variable": false,
        "value": "node=",
        "id": 7
    },
    {
        "is_variable": true,
        "value": "tohuvabohu.balabit",
        "regex": "[\\w.-]+",
        "id": 8,
        "description": "The hostname of the system where the reported event occurred. This is different from the hostname of the system where the audit event was logged.",
        "field_name": "event_host"
    },
    {
        "is_variable": false,
        "value": "type=",
        "id": 9
    },
    {
        "is_variable": true,
        "value": "ANOM_ABEND",
        "regex": "[A-Z_]+",
        "id": 10,
        "description": "The classification type of the audit event.",
        "field_name": "event_type"
    },
    {
        "is_variable": false,
        "value": "msg=audit(",
        "id": 11
    },
    {
        "is_variable": true,
        "value": "1410509823.256",
        "regex": "\\d+\\.\\d+",
        "id": 12,
        "description": "The Unix timestamp when the event occurred, with millisecond precision.",
        "field_name": "event_timestamp"
    },
    {
        "is_variable": false,
        "value": ":",
        "id": 13
    },
    {
        "is_variable": true,
        "value": "24937",
        "regex": "\\d+",
        "id": 14,
        "description": "The unique serial number assigned to this audit event, which helps maintain sequence and identify specific events in audit logs",
        "field_name": "event_sequence"
    },
    {
        "is_variable": false,
        "value": "): auid=",
        "id": 15
    },
    {
        "is_variable": true,
        "value": "1000",
        "regex": "\\d+",
        "id": 16,
        "description": "The audit user ID (audit user ID) of the user that ran the program or application that triggered this event. This ID is assigned to a user upon login and is inherited by every process even when the user's identity changes (for example, by switching user accounts with su - john).",
        "field_name": "audit_user_id"
    },
    {
        "is_variable": false,
        "value": "uid=",
        "id": 17
    },
    {
        "is_variable": true,
        "value": "1000",
        "regex": "\\d+",
        "id": 18,
        "description": "The user ID (uid) of the user that ran the program or application that triggered this event.",
        "field_name": "user_id"
    },
    {
        "is_variable": false,
        "value": "gid=",
        "id": 19
    },
    {
        "is_variable": true,
        "value": "1000",
        "regex": "\\d+",
        "id": 20,
        "description": "The primary group ID (gid) of the user that ran the program or application that triggered this event.",
        "field_name": "group_id"
    },
    {
        "is_variable": false,
        "value": "ses=",
        "id": 21
    },
    {
        "is_variable": true,
        "value": "13",
        "regex": "\\d+",
        "id": 22,
        "description": "The unique session identifier assigned when the user logged in, used to group all audit events from the same login session",
        "field_name": "session_id"
    },
    {
        "is_variable": false,
        "value": "subj=",
        "id": 23
    },
    {
        "is_variable": true,
        "value": "unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023",
        "regex": "[\\w:.-]+",
        "id": 24,
        "description": "The full SELinux security context of the process at the time of the event, including user, role, type, and sensitivity level information used for mandatory access control",
        "field_name": "selinux_context"
    },
    {
        "is_variable": false,
        "value": "pid=",
        "id": 25
    },
    {
        "is_variable": true,
        "value": "3759",
        "regex": "\\d+",
        "id": 26,
        "description": "The process ID (pid) of the specific program or application that generated the audit event, used to track the exact process instance involved",
        "field_name": "process_id"
    },
    {
        "is_variable": false,
        "value": "comm=\"",
        "id": 27
    },
    {
        "is_variable": true,
        "value": "gmain",
        "regex": "\\S+",
        "id": 28,
        "description": "The command name or process name of the program that generated the audit event, typically derived from the executable name or how the process was invoked",
        "field_name": "process_name"
    },
    {
        "is_variable": false,
        "value": "\" exe=\"",
        "id": 29
    },
    {
        "is_variable": true,
        "value": "/usr/bin/caja",
        "regex": "\\S+",
        "id": 30,
        "description": "The full path to the executable file that was running when the audit event occurred, helping identify the exact program involved in the event",
        "field_name": "executable_path"
    },
    {
        "is_variable": false,
        "value": "\" sig=",
        "id": 31
    },
    {
        "is_variable": true,
        "value": "11",
        "regex": "\\d+",
        "id": 32,
        "description": "The signal number that caused the process to terminate abnormally.",
        "field_name": "signal_number"
    }
]"""

    example_output = """{
    "log_timestamp": {
        "description": "The exact date and time when the audit event was recorded by the system, in local timezone format.",
        "ids": [1]
    },
    "log_host": {
        "description": "The hostname of the system where the audit event was logged. This is different from the hostname of the system where the reported event occurred.",
        "ids": [2]
    },
    "dispatcher_pid": {
        "description": "The process identifier (pid) of the audit dispatcher daemon that forwarded this audit event to the logging system",
        "ids": [5]
    },
    "event_host": {
        "description": "The hostname of the system where the reported event occurred. This is different from the hostname of the system where the audit event was logged.",
        "ids": [8]
    },
    "event_type": {
        "description": "The classification type of the audit event.",
        "ids": [10]
    },
    "event_timestamp": {
        "description": "The Unix timestamp when the event occurred, with millisecond precision.",
        "ids": [12]
    },
    "event_sequence": {
        "description": "The unique serial number assigned to this audit event, which helps maintain sequence and identify specific events in audit logs",
        "ids": [14]
    },
    "audit_user_id": {
        "description": "The audit user ID (audit user ID) of the user that ran the program or application that triggered this event. This ID is assigned to a user upon login and is inherited by every process even when the user's identity changes (for example, by switching user accounts with su - john).",
        "ids": [16]
    },
    "user_id": {
        "description": "The user ID (uid) of the user that ran the program or application that triggered this event.",
        "ids": [18]
    },
    "group_id": {
        "description": "The primary group ID (gid) of the user that ran the program or application that triggered this event.",
        "ids": [20]
    },
    "session_id": {
        "description": "The unique session identifier assigned when the user logged in, used to group all audit events from the same login session",
        "ids": [22]
    },
    "selinux_context": {
        "description": "The full SELinux security context of the process at the time of the event, including user, role, type, and sensitivity level information used for mandatory access control",
        "ids": [24]
    },
    "process_id": {
        "description": "The process ID (pid) of the specific program or application that generated the audit event, used to track the exact process instance involved",
        "ids": [26]
    },
    "process_name": {
        "description": "The command name or process name of the program that generated the audit event, typically derived from the executable name or how the process was invoked",
        "ids": [28]
    },
    "executable_path": {
        "description": "The full path to the executable file that was running when the audit event occurred, helping identify the exact program involved in the event",
        "ids": [30]
    },
    "signal_number": {
        "description": "The signal number that caused the process to terminate abnormally.",
        "ids": [32]
    }
}"""

    few_shot_examples.append((example_lines, example_template, example_output))

    example_lines = [
        "update-alternatives 2022-10-04 22:32:23: run with --install /usr/bin/groovysh groovysh /usr/share/groovy/bin/groovysh 20 --slave /usr/bin/groovy groovy /usr/share/groovy/bin/groovy --slave /usr/share/man/man1/groovysh.1.gz groovysh.1.gz /usr/share/groovy/man/man1/groovysh.1.gz",
        "update-alternatives 2022-10-04 22:35:45: run with --install /usr/bin/java java /usr/lib/jvm/java-11/bin/java 100 --slave /usr/bin/javac javac /usr/lib/jvm/java-11/bin/javac --slave /usr/share/man/man1/java.1.gz java.1.gz /usr/lib/jvm/java-11/man/man1/java.1.gz",
        "update-alternatives 2022-10-04 22:37:12: run with --install /usr/bin/python python /usr/bin/python3.8 30 --slave /usr/bin/python-config python-config /usr/bin/python3.8-config --slave /usr/share/man/man1/python.1.gz python.1.gz /usr/share/man/man1/python3.8.1.gz",
        "update-alternatives 2022-10-04 22:38:01: run with --install /usr/bin/gcc gcc /usr/bin/gcc-9 50 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/share/man/man1/gcc.1.gz gcc.1.gz /usr/share/man/man1/gcc-9.1.gz",
        "update-alternatives 2022-10-04 22:39:15: run with --install /usr/bin/node node /usr/local/node-v14/bin/node 40 --slave /usr/bin/npm npm /usr/local/node-v14/bin/npm --slave /usr/share/man/man1/node.1.gz node.1.gz /usr/local/node-v14/share/man/man1/node.1.gz",
    ]
    example_template = """[
{
"is_variable": true,
"value": "2022-10-04 22:32:23",
"regex": "\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2}",
"id": 1,
"description": "The date and time when the log event was recorded in the alternatives system. This timestamp helps track when changes were made to the system's alternative configurations."
},
{
"is_variable": false,
"value": "update-alternatives",
"id": 2
},
{
"is_variable": false,
"value": ": run with --install",
"id": 3
},
{
"is_variable": true,
"value": "/usr/bin/groovysh",
"regex": "/[\\w/.-]+",
"id": 4,
"description": "The destination path where the alternative link will be created in the filesystem. This symbolic link will point to one of several possible implementations of the command."
},
{
"is_variable": true,
"value": "groovysh",
"regex": "\\w+",
"id": 5,
"description": "The name of the link group for this alternative in the system. This identifier is used to group related alternatives together and manage them as a set."
},
{
"is_variable": true,
"value": "/usr/share/groovy/bin/groovysh",
"regex": "/[\\w/.-]+",
"id": 6,
"description": "The path to the actual executable being installed as an alternative. This is the real file that will be executed when the alternative link is used."
},
{
"is_variable": true,
"value": "20",
"regex": "\\d+",
"id": 7,
"description": "The priority of this alternative in the system's selection process. Higher numbers indicate higher priority, which determines which alternative becomes the default when automatic mode is enabled."
},
{
"is_variable": false,
"value": "--slave",
"id": 8
},
{
"is_variable": true,
"value": "/usr/bin/groovy",
"regex": "/[\\w/.-]+",
"id": 9,
"description": "The destination path for a slave link that is associated with the main alternative. Slave links are secondary symlinks that are updated along with the master alternative."
},
{
"is_variable": true,
"value": "groovy", 
"regex": "\\w+",
"id": 10,
"description": "The name of a slave link in the alternatives system. This identifier helps manage secondary components that should be switched together with the main alternative."
},
{
"is_variable": true,
"value": "/usr/share/groovy/bin/groovy",
"regex": "/[\\w/.-]+",
"id": 11,
"description": "The path to the actual file for a slave alternative. This is the real file that the slave symlink will point to when this alternative is selected."
},
{
"is_variable": false,
"value": "--slave",
"id": 12
},
{
"is_variable": true,
"value": "/usr/share/man/man1/groovysh.1.gz",
"regex": "/[\\w/.-]+",
"id": 13,
"description": "The destination path for a slave link that is associated with the main alternative. Slave links are secondary symlinks that are updated along with the master alternative."
},
{
"is_variable": true,
"value": "groovysh.1.gz",
"regex": "[\\w.-]+",
"id": 14,
"description": "The name of a slave link in the alternatives system. This identifier helps manage secondary components that should be switched together with the main alternative."
},
{
"is_variable": true,
"value": "/usr/share/groovy/man/man1/groovysh.1.gz",
"regex": "/[\\w/.-]+",
"id": 15,
"description": "The path to the actual file for a slave alternative. This is the real file that the slave symlink will point to when this alternative is selected."
}
]"""

    example_output = """{
    "log_timestamp": {
        "description": "The date and time when the log event was recorded in the alternatives system. This timestamp helps track when changes were made to the system's alternative configurations.",
        "ids": [1]
    },
    "link_path": {
        "description": "The destination path where the alternative link will be created in the filesystem. This symbolic link will point to one of several possible implementations of the command.",
        "ids": [4]
    },
    "link_name": {
        "description": "The name of the link group for this alternative in the system. This identifier is used to group related alternatives together and manage them as a set.",
        "ids": [5]
    },
    "target_path": {
        "description": "The path to the actual executable being installed as an alternative. This is the real file that will be executed when the alternative link is used.",
        "ids": [6]
    },
    "priority": {
        "description": "The priority of this alternative in the system's selection process. Higher numbers indicate higher priority, which determines which alternative becomes the default when automatic mode is enabled.",
        "ids": [7]
    },
    "slave_link_path": {
        "description": "The destination path for a slave link that is associated with the main alternative. Slave links are secondary symlinks that are updated along with the master alternative.",
        "ids": [9, 13]
    },
    "slave_link_name": {
        "description": "The name of a slave link in the alternatives system. This identifier helps manage secondary components that should be switched together with the main alternative.",
        "ids": [10, 14]
    },
    "slave_target_path": {
        "description": "The path to the actual file for a slave alternative. This is the real file that the slave symlink will point to when this alternative is selected.",
        "ids": [11, 15]
    }
}"""

    few_shot_examples.append((example_lines, example_template, example_output))

    return few_shot_examples


fixed_few_shot_examples = gen_fixed_fewshot()
