system = """You are an expert log parser. You are given a few log lines that have been generated by the same program. These lines have been separated into constant tokens and entities. Your task is to provide a schema for these log lines that assigns each entity a field name and description. Some fields will already have been assigned a description and name. You must keep these.

# Scope

## Variables
* Every variable must be assigned a field name and description

## Constants 

### Default naming
* By default, constants should be assigned the field name "SYNTAX"
* This indicates the constant does not contain any information that is relevant to an analyst and not already contained in variables.
   
### Semantic constants
* Some constants contain useful information that should be assigned a field name:
   - Contains queryable information
   - The information is relevant to the event
   - The information is not contained in any variable
   - The constant could be considered a variable
   - The meaning of the constant is obvious and without it the event would not be interpretable or would lack information.
* Constants that follow all the above criteria should be assigned a field name
* This name must follow the same rules as variables
   
### Key in key-value pairs
* Key-value pairs have specific naming rules
* For key-value pairs in which both the value and key are fields, the name of the key field must be the same as the name of the value field, with "_KEY" appended to the end of the name. The description of the key field must "KEY".
* For key-value pairs in which only the key is a field, or if the value is not a single field, the name and description of the key field must be "SYNTAX". 
   
# Description Writing Instructions

## Core Principles
**Scope**: Write descriptions that characterize the role of variables in log events, not their values.
**Independence**: Descriptions must remain valid regardless of the specific values observed in any instance.

## Quality Requirements

### Completeness
* Include all information necessary to understand the variable's role
* Cover the full scope of the variable's function in the context
* Explain any relevant relationships with other fields

### Precision
* Use accurate technical terminology
* Avoid ambiguous or vague language
* Be explicit about the variable's purpose
* Maintain consistent technical depth

### Soundness
* Ensure descriptions align with the technical reality of the variable's role
* Avoid misleading or incorrect characterizations
* Stay within the bounds of what is definitively known about the variable

## Guidelines for Consistency

### Cross-Reference Requirements
* When describing a variable similar to one previously described:
  - Review the earlier description
  - Maintain consistent terminology
  - Use parallel structure
  - Preserve the same level of detail

### Language Standards
* Use clear, professional technical writing
* Write in complete sentences
* Maintain consistent verb tense
* Use active voice

## What to Avoid
* Specific values or examples
* Assumptions about typical or possible values
* Instance-specific observations
* References to implementation details that may change
* Speculative functionality

# Field Naming Instructions

## Core Principles

**Abstract Role**: Names must represent the fundamental semantic role of the field in the event structure, independent of:
   - Any specific values it might contain
   - The specific system generating the log
   - The specific type of event being logged
   
**Structural Context**: Names should reflect the field's position and purpose in the event's logical structure:
   - What information does this field provide about the event?
   - How does this field relate to other fields?
   - What aspect of the event does this field describe?

**Universal Applicability**: Names must be valid across:
   - All possible values the field could contain
   - All types of events where this field appears
   - All systems that might generate similar events
   
## Implementation Rules

### Format:
* Use snake_case
* Use singular nouns
* Avoid vendor names, product names, or technology-specific terms
* Maximum 3 words joined by underscores

### Field Grouping:
* Fields serving the same semantic role MUST use identical names
* When grouping fields, list all matching IDs in the schema
* Cross-reference previous schemas to maintain consistency

### Naming Structure:
* If the original element included a field_name, please reuse it
* Start with the most general category (e.g., 'time', 'sequence', 'host')
* Add specificity only when needed to disambiguate
* Maintain parallel structure across related fields

## Validation Checklist

Before finalizing field names, verify:
1. Would the name still make sense if the field contained different values?
2. Does the name depend on any specific technology or system?
3. Is this name identical to names used for similar fields in other schemas?
4. Could this field appear in other types of events with the same meaning?
5. All fields that end with "_KEY" have a corresponding field without the suffix.

## What to Avoid

### Technology-Specific Terms:
* No implementation-specific terminology

### Value-Based Names:
* No names that describe specific values
* No names that assume specific formats or types
* No names that limit the field's interpretation

### Overly Specific Names:
* No names that incorporate current use cases
* No names that assume specific contexts
* No names that limit future applications

### Generic Names:
* Avoid names that are too generic and might apply to fields that represent different entities or play different roles in the event structure.

# Consistency

* Make sure to be consistent with previous schemas 
* Any field that has the same purpose or role as in a prior schema should use the same field name. 
* Use previous schemas to guide the field name styles as well and maintain parallel structure.
* Make sure fields representing the same attribute have the same name. 
* Do not reuse names for attributes that play different roles.
"""


user_input = """The following lines have been generated by the same program:
```
{lines}
```

We have determined they can be parsed using the following template:
```
{template}
```

Please provide a schema for these log lines. Follow the intrustions provided above.
"""


def gen_fewshot(examples, field_mapping=None, descriptions=None):
    if not examples:
        examples = []

    fewshot_prompts = []
    for fs_lines, fs_template, fs_output in fixed_few_shot_examples + examples:
        lines = "\n".join(fs_lines)
        if isinstance(fs_template, str):
            template = fs_template
        else:
            template = fs_template.format_as_example(
                force_match_with_entry=True,
                entry=fs_lines[0],
                regex=True,
                ids=True,
                descriptions=None,
                field_names=None,
            )
        if isinstance(fs_output, str):
            response = fs_output
        else:
            response = fs_output.to_json()

        prompt = user_input.format(lines=lines, template=template)
        fewshot_prompts.append({"role": "user", "content": prompt})
        fewshot_prompts.append({"role": "assistant", "content": response})

    return fewshot_prompts


def gen_system():
    return system


def gen_prompt(elt, few_shot_examples, field_mapping=None, descriptions=None):
    lines, template = elt
    if not isinstance(template, str):
        template = template.format_as_example(
            force_match_with_entry=True,
            entry=lines[0],
            regex=True,
            ids=True,
            descriptions=descriptions,
            field_names=field_mapping,
        )
    lines = "\n".join(lines)

    fewshot = gen_fewshot(few_shot_examples, field_mapping, descriptions)

    prompt = user_input.format(
        lines=lines,
        template=template,
    )

    return prompt, fewshot, gen_system()


def gen_fixed_fewshot():
    few_shot_examples = []
    example_lines = [
        'Sep 12 10:17:03 tohuvabohu.balabit audispd[1026]: node=tohuvabohu.balabit type=ANOM_ABEND msg=audit(1410509823.256:24937): auid=1000 uid=1000 gid=1000 ses=13 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=3759 comm="gmain" exe="/usr/bin/caja" sig=11',
        'Oct 17 22:12:33 tohuvabohu.balabit audispd[1030]: node=tohuvabohu.balabit type=ANOM_ABEND msg=audit(1413576753.722:253): auid=1000 uid=1000 gid=1000 ses=2 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=2755 comm="cinnamon" exe="/usr/bin/cinnamon" sig=11',
        'Sep 15 14:23:45 server1.company.com audispd[2047]: node=server1.company.com type=ANOM_ABEND msg=audit(1410678925.123:35891): auid=2000 uid=2000 gid=2000 ses=24 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=4891 comm="apache2" exe="/usr/sbin/apache2" sig=6',
        'Sep 18 03:15:22 db2.company.com audispd[3098]: node=db2.company.com type=ANOM_ABEND msg=audit(1410891322.445:47129): auid=3000 uid=3000 gid=3000 ses=31 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=5922 comm="mysqld" exe="/usr/sbin/mysqld" sig=11',
        'Sep 21 19:45:11 cache3.company.com audispd[4156]: node=cache3.company.com type=ANOM_ABEND msg=audit(1411321511.789:58234): auid=4000 uid=4000 gid=4000 ses=42 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 pid=7845 comm="redis-server" exe="/usr/bin/redis-server" sig=9',
    ]
    example_template = """[
    {
        "is_variable": true,
        "value": "Sep 12 10:17:03",
        "regex": "[A-Za-z]+\\s+\\d+\\s+\\d+:\\d+:\\d+",
        "id": 1,
        "description": "The exact date and time when the audit event was recorded by the system, in local timezone format.",
        "field_name": "log_timestamp"
    },
    {
        "is_variable": true,
        "value": "tohuvabohu.balabit", 
        "regex": "[\\w.-]+",
        "id": 2,
        "description": "The hostname of the system where the audit event was logged. This is different from the hostname of the system where the reported event occurred.",
        "field_name": "log_host"
    },
    {
        "is_variable": false,
        "value": "audispd",
        "id": 3
    },
    {
        "is_variable": false,
        "value": "[",
        "id": 4
    },
    {
        "is_variable": true,
        "value": "1026",
        "regex": "\\d+", 
        "id": 5,
        "description": "The process identifier (pid) of the audit dispatcher daemon that forwarded this audit event to the logging system",
        "field_name": "dispatcher_pid"
    },
    {
        "is_variable": false,
        "value": "]",
        "id": 6
    },
    {
        "is_variable": false,
        "value": "node=",
        "id": 7
    },
    {
        "is_variable": true,
        "value": "tohuvabohu.balabit",
        "regex": "[\\w.-]+",
        "id": 8,
        "description": "The hostname of the system where the reported event occurred. This is different from the hostname of the system where the audit event was logged.",
        "field_name": "event_host"
    },
    {
        "is_variable": false,
        "value": "type=",
        "id": 9
    },
    {
        "is_variable": true,
        "value": "ANOM_ABEND",
        "regex": "[A-Z_]+",
        "id": 10,
        "description": "The classification type of the audit event.",
        "field_name": "event_type"
    },
    {
        "is_variable": false,
        "value": "msg=audit(",
        "id": 11
    },
    {
        "is_variable": true,
        "value": "1410509823.256",
        "regex": "\\d+\\.\\d+",
        "id": 12,
        "description": "The Unix timestamp when the event occurred, with millisecond precision.",
        "field_name": "event_timestamp"
    },
    {
        "is_variable": false,
        "value": ":",
        "id": 13
    },
    {
        "is_variable": true,
        "value": "24937",
        "regex": "\\d+",
        "id": 14,
        "description": "The unique serial number assigned to this audit event, which helps maintain sequence and identify specific events in audit logs",
        "field_name": "event_sequence"
    },
    {
        "is_variable": false,
        "value": "): auid=",
        "id": 15
    },
    {
        "is_variable": true,
        "value": "1000",
        "regex": "\\d+",
        "id": 16,
        "description": "The audit user ID (audit user ID) of the user that ran the program or application that triggered this event. This ID is assigned to a user upon login and is inherited by every process even when the user's identity changes (for example, by switching user accounts with su - john).",
        "field_name": "audit_user_id"
    },
    {
        "is_variable": false,
        "value": "uid=",
        "id": 17
    },
    {
        "is_variable": true,
        "value": "1000",
        "regex": "\\d+",
        "id": 18,
        "description": "The user ID (uid) of the user that ran the program or application that triggered this event.",
        "field_name": "user_id"
    },
    {
        "is_variable": false,
        "value": "gid=",
        "id": 19
    },
    {
        "is_variable": true,
        "value": "1000",
        "regex": "\\d+",
        "id": 20,
        "description": "The primary group ID (gid) of the user that ran the program or application that triggered this event.",
        "field_name": "group_id"
    },
    {
        "is_variable": false,
        "value": "ses=",
        "id": 21
    },
    {
        "is_variable": true,
        "value": "13",
        "regex": "\\d+",
        "id": 22,
        "description": "The unique session identifier assigned when the user logged in, used to group all audit events from the same login session",
        "field_name": "session_id"
    },
    {
        "is_variable": false,
        "value": "subj=",
        "id": 23
    },
    {
        "is_variable": true,
        "value": "unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023",
        "regex": "[\\w:.-]+",
        "id": 24,
        "description": "The full SELinux security context of the process at the time of the event, including user, role, type, and sensitivity level information used for mandatory access control",
        "field_name": "selinux_context"
    },
    {
        "is_variable": false,
        "value": "pid=",
        "id": 25
    },
    {
        "is_variable": true,
        "value": "3759",
        "regex": "\\d+",
        "id": 26,
        "description": "The process ID (pid) of the specific program or application that generated the audit event, used to track the exact process instance involved",
        "field_name": "process_id"
    },
    {
        "is_variable": false,
        "value": "comm=\"",
        "id": 27
    },
    {
        "is_variable": true,
        "value": "gmain",
        "regex": "\\S+",
        "id": 28,
        "description": "The command name or process name of the program that generated the audit event, typically derived from the executable name or how the process was invoked",
        "field_name": "process_name"
    },
    {
        "is_variable": false,
        "value": "\" exe=\"",
        "id": 29
    },
    {
        "is_variable": true,
        "value": "/usr/bin/caja",
        "regex": "\\S+",
        "id": 30,
        "description": "The full path to the executable file that was running when the audit event occurred, helping identify the exact program involved in the event",
        "field_name": "executable_path"
    },
    {
        "is_variable": false,
        "value": "\" sig=",
        "id": 31
    },
    {
        "is_variable": true,
        "value": "11",
        "regex": "\\d+",
        "id": 32,
        "description": "The signal number that caused the process to terminate abnormally.",
        "field_name": "signal_number"
    }
]"""

    example_output = """{
"log_timestamp": {
    "description": "The exact date and time when the audit event was recorded by the system, in local timezone format.",
    "ids": [1]
},
"log_host": {
    "description": "The hostname of the system where the audit event was logged. This is different from the hostname of the system where the reported event occurred.",
    "ids": [2]
},
"process_name": {
    "description": "The name of the process that generated the event.",
    "ids": [3]
},
"SYNTAX": {
    "description": "SYNTAX",
    "ids": [4, 6, 13]
},
"dispatcher_pid": {
    "description": "The process identifier (pid) of the audit dispatcher daemon that forwarded this audit event to the logging system",
    "ids": [5]
},
"event_host_KEY": {
    "description": "KEY",
    "ids": [7]
},
"event_host": {
    "description": "The hostname of the system where the reported event occurred. This is different from the hostname of the system where the audit event was logged.",
    "ids": [8]
},
"event_type_KEY": {
    "description": "KEY",
    "ids": [9]
},
"event_type": {
    "description": "The classification type of the audit event.",
    "ids": [10]
},
"event_timestamp_KEY": {
    "description": "KEY",
    "ids": [11]
},
"event_timestamp": {
    "description": "The Unix timestamp when the event occurred, with millisecond precision.",
    "ids": [12]
},
"event_sequence": {
    "description": "The unique serial number assigned to this audit event, which helps maintain sequence and identify specific events in audit logs",
    "ids": [14]
},
"audit_user_id_KEY": {
    "description": "KEY",
    "ids": [15]
},
"audit_user_id": {
    "description": "The audit user ID (audit user ID) of the user that ran the program or application that triggered this event. This ID is assigned to a user upon login and is inherited by every process even when the user's identity changes (for example, by switching user accounts with su - john).",
    "ids": [16]
},
"user_id_KEY": {
    "description": "KEY",
    "ids": [17]
},
"user_id": {
    "description": "The user ID (uid) of the user that ran the program or application that triggered this event.",
    "ids": [18]
},
"group_id_KEY": {
    "description": "KEY",
    "ids": [19]
},
"group_id": {
    "description": "The primary group ID (gid) of the user that ran the program or application that triggered this event.",
    "ids": [20]
},
"session_id_KEY": {
    "description": "KEY",
    "ids": [21]
},
"session_id": {
    "description": "The unique session identifier assigned when the user logged in, used to group all audit events from the same login session",
    "ids": [22]
},
"selinux_context_KEY": {
    "description": "KEY",
    "ids": [23]
},
"selinux_context": {
    "description": "The full SELinux security context of the process at the time of the event, including user, role, type, and sensitivity level information used for mandatory access control",
    "ids": [24]
},
"process_id_KEY": {
    "description": "KEY",
    "ids": [25]
},
"process_id": {
    "description": "The process ID (pid) of the specific program or application that generated the audit event, used to track the exact process instance involved",
    "ids": [26]
},
"process_name_KEY": {
    "description": "KEY",
    "ids": [27]
},
"process_name": {
    "description": "The command name or process name of the program that generated the audit event, typically derived from the executable name or how the process was invoked",
    "ids": [28]
},
"executable_path_KEY": {
    "description": "KEY",
    "ids": [29]
},
"executable_path": {
    "description": "The full path to the executable file that was running when the audit event occurred, helping identify the exact program involved in the event",
    "ids": [30]
},
"signal_number_KEY": {
    "description": "KEY",
    "ids": [31]
},
"signal_number": {
    "description": "The signal number that caused the process to terminate abnormally.",
    "ids": [32]
}
}"""

    few_shot_examples.append((example_lines, example_template, example_output))

    example_lines = [
        "update-alternatives 2022-10-04 22:32:23: run with --install /usr/bin/groovysh groovysh /usr/share/groovy/bin/groovysh 20 --slave /usr/bin/groovy groovy /usr/share/groovy/bin/groovy --slave /usr/share/man/man1/groovysh.1.gz groovysh.1.gz /usr/share/groovy/man/man1/groovysh.1.gz",
        "update-alternatives 2022-10-04 22:35:45: run with --install /usr/bin/java java /usr/lib/jvm/java-11/bin/java 100 --slave /usr/bin/javac javac /usr/lib/jvm/java-11/bin/javac --slave /usr/share/man/man1/java.1.gz java.1.gz /usr/lib/jvm/java-11/man/man1/java.1.gz",
        "update-alternatives 2022-10-04 22:37:12: run with --install /usr/bin/python python /usr/bin/python3.8 30 --slave /usr/bin/python-config python-config /usr/bin/python3.8-config --slave /usr/share/man/man1/python.1.gz python.1.gz /usr/share/man/man1/python3.8.1.gz",
        "update-alternatives 2022-10-04 22:38:01: run with --install /usr/bin/gcc gcc /usr/bin/gcc-9 50 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/share/man/man1/gcc.1.gz gcc.1.gz /usr/share/man/man1/gcc-9.1.gz",
        "update-alternatives 2022-10-04 22:39:15: run with --install /usr/bin/node node /usr/local/node-v14/bin/node 40 --slave /usr/bin/npm npm /usr/local/node-v14/bin/npm --slave /usr/share/man/man1/node.1.gz node.1.gz /usr/local/node-v14/share/man/man1/node.1.gz",
    ]
    example_template = """[
{
"is_variable": true,
"value": "2022-10-04 22:32:23",
"regex": "\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2}",
"id": 1,
"description": "The date and time when the log event was recorded in the alternatives system. This timestamp helps track when changes were made to the system's alternative configurations."
},
{
"is_variable": false,
"value": "update-alternatives",
"id": 2
},
{
"is_variable": false,
"value": ": run with --install",
"id": 3
},
{
"is_variable": true,
"value": "/usr/bin/groovysh",
"regex": "/[\\w/.-]+",
"id": 4,
"description": "The destination path where the alternative link will be created in the filesystem. This symbolic link will point to one of several possible implementations of the command."
},
{
"is_variable": true,
"value": "groovysh",
"regex": "\\w+",
"id": 5,
"description": "The name of the link group for this alternative in the system. This identifier is used to group related alternatives together and manage them as a set."
},
{
"is_variable": true,
"value": "/usr/share/groovy/bin/groovysh",
"regex": "/[\\w/.-]+",
"id": 6,
"description": "The path to the actual executable being installed as an alternative. This is the real file that will be executed when the alternative link is used."
},
{
"is_variable": true,
"value": "20",
"regex": "\\d+",
"id": 7,
"description": "The priority of this alternative in the system's selection process. Higher numbers indicate higher priority, which determines which alternative becomes the default when automatic mode is enabled."
},
{
"is_variable": false,
"value": "--slave",
"id": 8
},
{
"is_variable": true,
"value": "/usr/bin/groovy",
"regex": "/[\\w/.-]+",
"id": 9,
"description": "The destination path for a slave link that is associated with the main alternative. Slave links are secondary symlinks that are updated along with the master alternative."
},
{
"is_variable": true,
"value": "groovy", 
"regex": "\\w+",
"id": 10,
"description": "The name of a slave link in the alternatives system. This identifier helps manage secondary components that should be switched together with the main alternative."
},
{
"is_variable": true,
"value": "/usr/share/groovy/bin/groovy",
"regex": "/[\\w/.-]+",
"id": 11,
"description": "The path to the actual file for a slave alternative. This is the real file that the slave symlink will point to when this alternative is selected."
},
{
"is_variable": false,
"value": "--slave",
"id": 12
},
{
"is_variable": true,
"value": "/usr/share/man/man1/groovysh.1.gz",
"regex": "/[\\w/.-]+",
"id": 13,
"description": "The destination path for a slave link that is associated with the main alternative. Slave links are secondary symlinks that are updated along with the master alternative."
},
{
"is_variable": true,
"value": "groovysh.1.gz",
"regex": "[\\w.-]+",
"id": 14,
"description": "The name of a slave link in the alternatives system. This identifier helps manage secondary components that should be switched together with the main alternative."
},
{
"is_variable": true,
"value": "/usr/share/groovy/man/man1/groovysh.1.gz",
"regex": "/[\\w/.-]+",
"id": 15,
"description": "The path to the actual file for a slave alternative. This is the real file that the slave symlink will point to when this alternative is selected."
}
]"""

    example_output = """{
    "SYNTAX": {
        "description": "SYNTAX",
        "ids": [3, 8, 12]
    },
    "log_timestamp": {
        "description": "The date and time when the log event was recorded in the alternatives system. This timestamp helps track when changes were made to the system's alternative configurations.",
        "ids": [1]
    },
    "process_name": {
        "description": "The name of the process that generated the event.",
        "ids": [2]
    },
    "link_path": {
        "description": "The destination path where the alternative link will be created in the filesystem. This symbolic link will point to one of several possible implementations of the command.",
        "ids": [4]
    },
    "link_name": {
        "description": "The name of the link group for this alternative in the system. This identifier is used to group related alternatives together and manage them as a set.",
        "ids": [5]
    },
    "target_path": {
        "description": "The path to the actual executable being installed as an alternative. This is the real file that will be executed when the alternative link is used.",
        "ids": [6]
    },
    "priority": {
        "description": "The priority of this alternative in the system's selection process. Higher numbers indicate higher priority, which determines which alternative becomes the default when automatic mode is enabled.",
        "ids": [7]
    },
    "slave_link_path": {
        "description": "The destination path for a slave link that is associated with the main alternative. Slave links are secondary symlinks that are updated along with the master alternative.",
        "ids": [9,13]
    },
    "slave_link_name": {
        "description": "The name of a slave link in the alternatives system. This identifier helps manage secondary components that should be switched together with the main alternative.",
        "ids": [10,14]
    },
    "slave_target_path": {
        "description": "The path to the actual file for a slave alternative. This is the real file that the slave symlink will point to when this alternative is selected.",
        "ids": [11,15]
    }
}"""

    few_shot_examples.append((example_lines, example_template, example_output))

    return few_shot_examples


fixed_few_shot_examples = gen_fixed_fewshot()
